---
title: Wecode 2차 프로젝트 OURSPACE 회고
category: project
tag:
    - python
    - django
    - mysql
---
<div align=center style='background-color:thistle'>
<br>
<h1>OURSPACE</h1>
<br>
</div>

<div align=center><img src='https://user-images.githubusercontent.com/84963683/136654713-4d85ac2c-019a-4c26-aa46-ba5a2fe3fc43.gif'></div>

> 구현 웹사이트 : [스페이스클라우드](https://www.spacecloud.kr/)<br>
> 프론트엔드 : 심택준, 이수정, 이현준, 최호정 (4명)<br>
> 백엔드 : 임종성, 장이주 (2명)<br>
> 링크 : [유튜브](https://www.youtube.com/watch?v=8b4LgFIEaCk&ab_channel=TaekjunSim), [깃허브](https://github.com/Jang184/23-2nd-OURSPACE-backend)

---

# <span style='color:mediumorchid'>백엔드 구현 기능 목록</span>
<span style='background-color:thistle'>사용기술 : Python, Django, Mysql, AWS EC2, RDS, S3,Docker, POSTMAN</span>
1. 카카오 API를 이용한 소셜 로그인 API
2. 공간목록 필터링 및 정렬 API
3. AWS S3 를 통한 이미지 호스팅 관리
4. 공간등록 API
5. 예약 관련 API
6. Unit Test / 성능 최적화 / Docker를 이용한 배포 과정

# <span style='color:mediumorchid'>모델링</span>
![image](https://user-images.githubusercontent.com/81026531/136741227-fd545c23-ba8d-4709-927b-837eb7d182df.png)

# <span style='color:mediumorchid'>1. 카카오 API를 이용한 소셜 로그인 API</span>
<div align=center><img src='https://user-images.githubusercontent.com/84963683/136654810-232792c4-4ab1-4479-b20e-4baba445abf5.gif'></center>
<span>참고 : <a href='https://developers.kakao.com/docs/latest/ko/kakaologin/common'>KakaoDevelopers 로그인</a></span>

## ▶️ 전체적인 흐름
<img src='https://media.vlpt.us/images/e2joo418/post/63319340-8caa-4023-8727-be17244f0ce9/image.png'>

카카오 로그인 API를 이용한 소셜로그인 기능은 크게 세가지의 단계로 이루어진다.
1. 인증코드 받기
2. 인증코드로 토큰 받기
3. 받은 토큰으로 사용자정보 받기

보통 프론트엔드에서 1번과 2번을 수행한 후 카카오 서버로부터 받은 토큰을 백엔드 서버로 보내고, 백엔드에서 그 토큰으로 카카오로부터 사용자 정보를 받아온다.<br>
위의 모든 과정은 백엔드에서 처리할 수 있다. 하지만 이렇게 할 경우엔 가끔 발생하는 오류가 있어서 적당히 프론트와 분업 후 하는 것이 안정적이라는 조언을 얻었다.

## ▶️ CODE

```
access_token = request.headers.get('Authorization')
```
1) 프론트엔드에서 요청메세지의 헤더에 카카오로부터 받은 토큰을 담아 백엔드 서버로 보내준다. 

```
url           = 'https://kapi.kakao.com/v2/user/me'
response      = requests.get(url, headers={'Authorization': f'Bearer {access_token}'})
user_response = response.json()
```
2) 프론트로부터 받은 헤더를 카카오서버로 보내 카카오서버에 저장된 사용자의 정보를 받아온다.

```
user,created = User.objects.get_or_create(kakao_id=user_response['id'],nickname = user_response['properties']['nickname'])

if created: 
    user.email    = user_response['kakao_account']['email']
    user.nickname = user_response['properties']['nickname']
    user.point    = random.randrange(0,10000)
    user.save()

token = jwt.encode({'id':user.id}, SECRET_KEY, algorithm= 'HS256')

return JsonResponse({'access_token':token}, status=200)
```

3) DB에 저장된 사용자의 정보와 비교해 이미 정보가 저장된(이미 회원가입을 한) 사용자라면 토큰을 생성 후 프론트엔드로 반환, 정보가 없는 사용자라면 회원가입을 진행한 후(DB에 사용자 정보를 저장) 토큰을 생성해 프론트엔드로 반환한다.

# <span style='color:mediumorchid'>2-1. 공간목록 필터링 및 정렬 API</span>

<img src='https://user-images.githubusercontent.com/84963683/136654768-29398d80-2502-4c9c-bff4-1e36e4f9776f.gif'>

## ▶️ 딕셔너리를 이용해 공간 정렬하기

```
prefix = {
        "desc"  : "-day_price",
        "aesc"  : "day_price",
        "best"  : "-like" 
    }
```

## ▶️ Q객체를 이용해서 조건에 맞는 공간 필터링하기 

```
q = Q()

if district_id:
    q &= Q(district_id = district_id)

if category_id:
    q &= Q(category_id = category_id)

if man_count:
    q &= Q(min_count__lte = man_count) & Q(max_count__gte = man_count)

if date:
    q_exclude = Q(order__status_id=OrderStatus.Status.COMPLETED.value) & Q(order__date=date)
    q_exclude &= ((Q(order__option__option="all") | Q(count_option = 2)))
    q &= ~q_exclude
```

조건에 맞는 공간만 필터링 후 반환한다.
1) 지역 (district)
2) 공간유형 (category)
3) 인원수 (man_count)
최소인원은 2명으로 고정, 사용자가 입력한 인원수를 최대인원으로 설정한다.
4) 예약날짜 (date)
`q_exclude`
- 지정한 날짜에 있는 예약 중에서 결제가 완료된 (Status.COMPLETED) 주문을 저장한다.
- 종일예약을 한 주문(option="all")과 오전, 오후 모두 예약한 주문(count_option = 2)을 저장한다. 

```
spaces = Space.objects.prefetch_related("image_set").select_related('district')\
                .annotate(day_price=Min('option__price'), count_option = Count('order', distinct=True))\
                .filter(q).order_by(prefix.get(order, "-like"))
```
반환할 공간 객체를 `space`에 저장한다. 
1. 공간 이미지와 지역에 대한 정보는 미리 가져와서 캐싱해두어 DB를 hit 횟수를 줄인다. 
2. 공간 가격을 최소 가격으로 지정하고 해당 공간의 주문 횟수를 중복없이 카운팅한다. 
3. `q`에 저장한 조건을 이용해 필터링한다.
4. 좋아요 수에 대해 오름차순으로 정렬한다.

# <span style='color:mediumorchid'>2-2. 공간에 대한 지역과 카테고리 정보</span>

프론트단에서 지역과 카테고리에 대한 아이콘과 텍스트를 하드코딩하지 않도록 서버에서 정보를 보내주기로 결정했다.

```
class DistrictView(View):
    def get(self, request):
        result = [{
                    "id"        : district.id,
                    "name"      : district.name,
                    "lattitude" : district.lattitude,
                    "longitude" : district.longitude 
                } for district in District.objects.all()]

        return JsonResponse({'RESULT':result}, status=200)

class CategoryView(View):
    def get(self, request):
        result = [{
            "id"    : category.id, 
            "name"  : category.name,
            "image" : category.image
        } for category in Category.objects.all()]

        return JsonResponse({'RESULT':result}, status=200)
```

# <span style='color:mediumorchid'>3. AWS S3 를 통한 이미지 호스팅 관리</span>

## ▶️ uuid를 사용해 파일명 중복 방지하기
```
signs  = [{'key':'image/' + str(uuid.uuid4()) + image.name, 'image' : image} for image in images]
```
AWS S3에 파일명이 중복된 채로 업로드되면 새로운 이미지가 기존에 저장된 이미지를 대체한다. 이와 같은 데이터 유실을 막기위해 `uuid`를 사용해 경로에 임의의 문자열을 붙여 업로드한다.
> 경로 : image/'uuid문자열'+'파일명'

## ▶️ S3 업로드 로직의 모듈화 - boto3 

```
s3_client = S3Client(AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)  
```
```
# storage.py

class S3Client():
    def __init__(self, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY):
        self.s3 = boto3.client(
        's3',
        aws_access_key_id = AWS_ACCESS_KEY_ID,
        aws_secret_access_key = AWS_SECRET_ACCESS_KEY
        )
        self.base = 'static/'
    
    def __del__(self):
        return None

    def upload(self, file, file_name, bucket_name):
        self.s3.upload_fileobj(
            file,
            bucket_name,
            self.base + file_name,
            ExtraArgs = {
                'ContentType' : file.content_type
            }
        )
    
    def delete(self, file_name, bucket_name):
        self.s3.delete_object(Bucket=bucket_name, Key = self.base + file_name)
```
```
Image.objects.bulk_create([
        Image(space=space, image = AWS_S3_DIRS + sign['key'])
        for sign in signs
])
for sign in signs: 
        s3_client.upload(sign['image'], sign['key'], AWS_STORAGE_BUCKET_NAME)
```
# <span style='color:mediumorchid'>4. 공간등록 API</span>

## ▶️ Q객체를 이용해서 조건에 맞는 공간 필터링하기 

```
user       = request.user
data       = request.POST
min_count  = request.POST.get('min_count', 2)
like       = request.POST.get('like', 0)
images     = request.FILES.getlist('image')
facilities = request.POST.get('facility', None).split(',')
signs      = [{'key':'image/' + str(uuid.uuid4()) + image.name, 'image' : image} for image in images]
```
- request에 담아보낸 정보를 변수에 저장한다.
- 모든 데이터는 `formData`로 받았으며 `min_count`와`like`는 request에 포함되지 않는 값으로 default 처리를 했다.
- `images`는 `getlist`를 사용해 복수의 이미지를 저장했다.
- `facilities`는 formdata로 복수의 facility_id를 저장한다. 프론트에서 가공되지 않은 형태로 넘어와 백단에서 split을 이용해 가공했다.
