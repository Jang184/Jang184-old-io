---
title: Wecode 1차 프로젝트 GGUGIT 회고
category: project
tag: 
    - python
    - django
    - mysql
---

![menu-filter](https://user-images.githubusercontent.com/81026531/136691486-f0aa6658-5c13-477d-8553-83f804ddf14d.gif)

> 구현 웹사이트 : <a href="https://www.cjcookit.com/">쿡킷</a><br>
> 프론트엔드 : 김동우, 이지선, 황문실 (3명)<br>
> 백엔드 : 김훈태, 장이주 (2명)

# <span style='color:darkorange'>백엔드 구현 기능 목록</span>
1. 회원가입 / 로그인 API 및 로그인 데코레이터 
2. 상품목록 필터링,정렬 API
3. 상품상세정보 제공 API
4. 장바구니 CRUD API
5. 상품검색 API

2주차에 구매, 리뷰 기능을 구현하기로 한 기존 계획을 대폭 수정했다. 플랜미팅 후 1차 프로젝트가 협업을 경험해보기 위한 프로젝트인만큼 <span style='background-color:peachpuff'>프론트엔드와 백엔드의 진도를 맞춰서 진행하기로 결정</span>했고, 백엔드에서 독자적으로 더 많은 기능을 구현하는 것보다 <span style='background-color:peachpuff'>프론트엔드와 맞춰볼 수 있는 기능을 더 심화시켜 진행</span>하기로 합의했다.

# <span style='color:darkorange'>모델링</span>
![cook_20210808_44_44](https://user-images.githubusercontent.com/81026531/136691499-0e6f793b-eaea-49cf-8700-998b5c36f6e6.png)

- 다대다 관계인 product와 taste 주의 (중간테이블 이용)
- image와 description은 확장성을 고려해서 테이블을 별도로 생성
- 복수의 테이블을 참조하는 cart와 review 주의

모델링은 데이터간의 관계를 결정하는 중요한 단계이다. 이후의 코드작성을 포함한 모든 작업에 영향을 주는만큼 초기에 더 신중하게 시간을 들여 모델링을 해야한다. 또한, 확장성을 고려해 모델링을 하는 것도 중요하다.
모델을 수정하면 수정된 모델과 관련한 모든 코드를 수정해야하며 더 나아가 데이터베이스 자체를 통째로 갈아엎어야 할 수도 있다.(ㅠㅠ) 뭐든지 기초공사가 제일 중요하다.

# <span style='color:darkorange'>1-1. 회원가입 API </span>
## bcrypt를 이용해 사용자 패스워드 암호화 진행
```
data = json.loads(request.body)
hashed_password = bcrypt.hashpw(data['password'].encode('utf-8'),bcrypt.gensalt()).decode('utf-8')
```
request 메세지의 body에 담겨진 패스워드를 <u>bcrypt</u>를 이용해 암호화하여 DB에 저장한다.
## Error Case
```
#1)이메일 양식
if not re.search(r'^[a-z0-9]+[\._]?[a-z0-9]+[@]\w+[.]\w+[.]?\w{2,3}$', data['email']):
    return JsonResponse({'message':'NOT_EMAIL_FORMAT'}, status = 400)
#2)패스워드 양식
if not re.search(r'^(?=(.*[A-Za-z]))(?=(.*[0-9]))(?=(.*[@#$%^!&+=.\-_*]))([a-zA-Z0-9@#$%^!&+=*.\-_]){8,}$', data['password']):
    return JsonResponse({'message':'NOT_PASSWORD_FORMAT'}, status = 400)
#3)핸드폰번호 양식
if not re.search(r'^\d{3}-\d{3,4}-\d{4}$',data['phone_number']):
    return JsonResponse({'message':'INVALID_PHONE_NUMBER'}, status = 400)
#4)이메일 중복확인
if User.objects.filter(email=data['email']).exists():
    return JsonResponse({'message':'INVALID_EMAIL'}, status = 400)
#5)KeyError
``` 
## 사용자가 입력한 정보를 DB에 저장
```
User.objects.create(
    name         = data['name'],
    email        = data['email'],
    password     = hashed_password,
    phone_number = data['phone_number'],
    birthday     = data['birthday'],
)   
```
패스워드는 bcrypt를 이용해 암호화한 `hashed_password`로 저장한다.

# <span style='color:darkorange'>1-2. 로그인 API </span>
## Error Case
```
#1)이메일 가입여부 확인
if not User.objects.filter(email = data['email']).exists():
    return JsonResponse({'message':'INVALID_EMAIL'}, status = 401)
#2)비밀번호 일치여부 확인
if not bcrypt.checkpw(data['password'].encode('utf-8'), user.password.encode('utf-8')):
    return JsonResponse({'message':'INVALID_USER'}, status = 401)
#3)KeyError
```
## JWT를 이용해 access token 발행
```
access_token = jwt.encode({'id' : user.id}, SECRET_KEY, algorithm= 'HS256')
```
# <span style='color:darkorange'>1-3. 로그인 데코레이터</span>
```
def LoginDecorator(func):
    def wrapper(self,request, *args, **kwargs):
        try:
            access_token = request.headers.get('Authorization', None)
            payload      = jwt.decode(access_token ,SECRET_KEY, algorithms= 'HS256')
            user         = User.objects.get(id = payload['id'])
            request.user = user

        except jwt.exceptions.DecodeError:
            return JsonResponse({'message':'INVALID_TOKEN'}, status = 400)
        
        except ObjectDoesNotExist:
            return JsonResponse({'message':'INVALID_USER'}, status=400)

        return func(self,request, *args, **kwargs)
        
    return wrapper
```
