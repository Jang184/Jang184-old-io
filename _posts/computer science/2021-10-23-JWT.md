---
title: JWT (Json Web Token)
category: CS
tag: TIL
---

## 인증, 인가

>인증(Authentication): 로그인, 특정 서비스에 권한이 주어진 사용자임을 인증받는 것

>인가(Authorization) : 한 번 인증을 받은 사용자가 다른 기능을 사용할 때 서비스로부터 허가를 받는 것

## 왜 토큰을 사용할까?

무수히 많은 사용자가 서비스를 이용한다. 어떤 사용자가 방문자이고, 어떤 사용자가 서비스에 가입한 사용자인지 확인하기 위해서 `로그인`을 통해 `인증`을 한다. 서비스 내에서 다른 기능을 사용할 때마다 사용자는 인증을 받은 사용자라는 것을 `인가`받아야 한다. 만약 사용자가 서비스에 로그인을 한 이후 서비스의 다른 기능을 이용하려고 할 때마다 로그인을 한다면 그때마다 사용자가 입력한 비밀번호를 대조하기 위해 데이터베이스에 저장된 해쉬값을 꺼내와 알고리즘값을 계산하는 과정을 거쳐야 한다. 

>즉, 사용자가 어떤 기능을 요청할 때마다 로그인을 하는 것은 시간과 자원을 굉장히 많이 소모하는 작업이다!

## 세션 VS 토큰

세션아이디를 사용해서 어떤 사용자가 서버에 로그인을 지속하는 상태를 `세션`이라고 한다. 동시에 많은 사용자가 접속을 하면 메모리가 부족한 상황이 생길 수 있다. 또한, 서버가 재부팅되면 메모리에 있는 데이터가 모두 날라간다. 서버가 여러 대가 있으면 로그인한 서버와 서비스 요청을 보낸 서버가 다를 때 세션 유지에 문제가 발생한다. 


사용자가 로그인을 하면 토큰을 전달한다. 토큰은 암호화된 3가지 데이터인 `header`,`payload`,`signature`를 이어붙여서 만든다. payload에는 누가 누구에게 발급했는지, 토큰이 언제까지 유효한지, 서비스가 사용자에게 토큰을 통해 공개하는 내용이 담긴다. 사용자가 요청을 보낼때마다 서버에 토큰이 함께 보내지고 서버는 토큰에 있는 사용자에 대한 정보를 데이터베이스에 접근하지 않고도 확인이 가능하다. 이 떄, payload에 담기는 정보가 악용되지 않게 하기 위해서 헤더와 페이로드, 서버에 지정해놓은 secret_key를 사용해 암호화한 값을 서명값을 만든다. 

>서버는 요청 메세지로 전달된 토큰값의 헤더와 페이로드를 서버의 secret_key와 암호화한 결과값이 서명과 비교하여 일치하는지 확인한다. 

암호화한 결과값과 서명이 일치하고, 토큰의 유효기간이 지나지 않았다면 사용자는 토큰을 사용해 로그인된 회원으로서 인가를 받을 수 있다. 서버에 토큰을 저장해두지 않아도 요청이 들어올 때마다 토큰을 이용해 사용자들을 필터링할 수 있게 된다.

## JWT의 단점
세션처럼 모든 사용자의 상태를 기억하는 것은 고려사항이 많지만 기억하는 대상의 상태를 제어할 수 있다는 의미다. 예를 들어, 기존의 PC에 로그인 된 사용자가 모바일로 로그인을 했을 때 PC에서는 로그아웃이 되도록 기존 세션을 종료할 수 있다. 

토큰은 이미 줘버린 토큰을 서버에서 추적할 수 없기 때문에 통제를 할 수 없다. 이를 보완하기 위해 토큰의 수명을 짧게 주는 방법이 있다. 두 개의 토큰 `access token`(수명이 짧은 토큰)과 `refresh token`(비교적 긴 수명을 가지는 토큰) 을 발급해서 refresh token은 데이터베이스에 저장한다. 사용자는 access token이 만료하면 refresh token을 보내 서버가 데이터베이스와 비교한 후 새로 발급해주는 access token을 받아 사용한다. refresh token을 만료시켜 access token을 다시 발급받지 못하게 하는 방법으로 사용자의 로그인 상태를 제어할 수 있다. 

참고 : [유튜브 얄코](https://youtu.be/1QiOXWEbqYQ)